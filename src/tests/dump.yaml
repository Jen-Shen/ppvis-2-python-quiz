code: |
  print(bool('False'), bool('True'))
output: "True True"
tag:
  -  boolean/literal

---

code: |
  a = True

  a -= True
  print(a)
output: "0"
tag:
  -  boolean

---

code: |
  if True:
    print(1)
  else:
    print(0)
output: "1"
tag:
  -  boolean

---

code: |
  a = 0
  b = True
  c = a + b

  print(c is True)
output: "False"
tag:
  -  boolean/literal
  -  boolean/operation/add
  -  expression/operation/is

---

code: |
  a = "True"
  b = True
  c = 1

  print(a == b)
  print(b == c)
output: "False True"
tag:
  -  boolean/literal
  -  boolean/operation/compare

---

code: |
  lst = [True, False]

  print(lst[False])
  print(lst[lst[False]])
output: "True False"
tag:
  -  boolean/literal
  -  list/literal

---

code: |
  a = False

  for x in range(1, 3):
    a = not a

  print(a)
output: "False"
tag:
  -  boolean/literal
  -  boolean/operation/not
  -  build-in/range

---

code: |
  data = [([]), [()]]

  for i in data:
    print(bool(i), end=' ')
output: "False True"
tag:
  -  boolean/literal

---

code: |
  elements = ((), [], {}, 0, 0., "", False)
  print(any(elements))
output: "False"
tag:
  -  boolean #build-in/any

---

code: |
  x = bool("")

  print(x == True)
output: "False"
tag:
  -  string/literal
  -  boolean/operation/compare

---
code: |
  words = ['python', 'programmer', 'quizzes']

  for index, value in enumerate(words):
    if index % 2 == 0:
      print(value)
      break
output: "python"
tag:
  - built-in/enumerate
  - expression/operation/modulo

---

code: |
  lst = []
  lst.append(lst)

  print(lst)
output: "[[...]]"
tag:
  - build-in/print

---

code: |
  l = [[1, 2], [3, 4, 5]]
  print(sum(l, []))
output: "[1, 2, 3, 4, 5]"
tag:
  - build-in/sum

---

code: |
  print(callable(print))
output: "True"
tag:
  - build-in/callable

---

code: |
  list_of_tuple = [('bob', 35, 'mgr'), ('sue', 40, 'dev')]

  data = list(map((lambda row: row[2]), list_of_tuple))

  print(data)
output: "['mgr', 'dev']"
tag:
  - build-in/map
  - build-in/list
  - list/literal
  - tuple/literal
  - lambda

---

code: |
  x = None
  print(bool(x))
output: "False"
tag:
  - build-in/bool
  - build-in/print
  - boolean

---

code: |
  lst = [4.6, 2.3, 7.8]
  a = list([2, 5.9])

  for num in lst:
    a.append(int(num))

  print(a)
output: "[2, 5.9, 4, 2, 7]"
tag:
  - build-in/int
  - build-in/list
  - list/operation/append

---

code: |
  lst = [(2, 3), (2, 9), (5, 0)]

  a = dict(lst)

  print(a)
output: "{2: 9, 5: 0}"
tag:
  - build-in/dict
  - build-in/int
  - list/literal
  - tuple/literal

---

code: |
  lst = [3, 1, 2, 4, 1]

  sum_of_num = sum(lst, start=2)

  print(sum_of_num)
output: "13"
tag:
  - build-in/sum
  - list/literal

---

code: |
  lst = [-4, 0, 2, '', 7, 'a', ' ', -4]

  b = list(filter(None, lst))

  print(b)
output: "[-4, 2, 7, 'a', ' ', -4]"
tag:
  - build-in/filter
  - build-in/list
  - list/literal

---

code: |
  def check(x):
    if x % 2 == 0:
      return 1


  lst = [2, 1, 4, 5, 3]

  a = list(filter(check, lst))

  print(a)
output: "[2, 4]"
tag:
  - build-in/filter
  - build-in/list
  - expression/operation/modulo
  - list/literal

---

code: |
  lst = [3, 4, 'a', -1]

  a = sorted(lst, reverse=True)

  print(a)
output: "TypeError: '<' not supported between instances of 'str' and 'int'"
tag:
  - build-in/sorted
  - list/literal

---

code: |
  st = {1, 5, 6, 5}

  a = tuple(st)

  print(a)
output: "(1, 5, 6)"
tag:
  - build-in/tuple
  - set/literal

---

code: |
  tpl = (4, 1, 0, 'a')

  a = any(tpl)

  print(a)
output: "True"
tag:
  - build-in/any
  - tuple/literal
  - boolean

---

code: |
  lst = [2, 5, 5, 1, 3]

  itr = iter(lst)

  a = next(itr)
  b = next(itr)

  print(a, b)
output: "2 5"
tag:
  - build-in/iter
  - build-in/next
  - list/literal

---

code: |
  print('a' 'b' 'c' 'd')
output: "abcd"
tag:
  - build-in/print

---

code: |
  lst = [1, 2, 3, 4]

  r = 1

  for i in range(len(lst)):
    r *= i

  print(r)
output: "0"
tag:
  - build-in/range

---

code: |
  print(list(range(2, 15, 3)))
output: "[2, 5, 8, 11, 14]"
tag:
  - build-in/range
  - build-in/list

---

code: |
  print(all([]))
output: "True"
tag:
  - build-in/all

---

code: |
  func = lambda x : x % 2 == 0
  nums = filter(func, range(17))
  print(len(nums) + min(nums))
output: "TypeError: object of type 'filter' has no len()"
tag:
  - build-in/filter

---

code: |
  lst = [3, 1, 4, 'a', 2]

  a = tuple(reversed(lst))

  print(a)
output: "(2, 'a', 4, 1, 3)"
tag:
  - build-in/reversed
  - build-in/tuple
  - list/literal

---

code: |
  dct = {3: 4, -1: 9, 4: 1, -2: 4}

  num = max(dct, key=lambda k: dct[k])

  print(num)
output: "-1"
tag:
  - build-in/max
  - lambda
  - dict/literal

---

code: |
  lst_1 = [2, 5, 9, 0]
  lst_2 = [2, 5, 9]

  res = min(lst_1, lst_2)

  print(res)
output: "[2, 5, 9]"
tag:
  - build-in/min
  - list/literal

---

code: |
  a = pow(2, 3, 10)

  print(a)
output: "8"
tag:
  - build-in/pow

---

code: |
  str = 'abc'
  num = (10, 20, 30, 40)

  a = list(zip(str, num))

  print(a)
output: "[('a', 10), ('b', 20), ('c', 30)]"
tag:
  - build-in/zip
  - build-in/list
  - tuple/literal

---

code: |
  first, second = zip(*[(1, 4), (2, 5), (3, 6)])

  print(first, second)
output: "(1, 2, 3) (4, 5, 6)"
tag:
  - build-in/zip
  - list/literal
  - tuple/literal

---

code: |
  dct = {1: 2, 2: 3, 3: 4, 4: [2, 5, 6]}

  b = len(dct)

  print(b)
output: "4"
tag:
  - build-in/len
  - dict/literal

---

code: |
  if all([2, 0, 4]):
    print("Yes")
  else:
    print("No")
output: "No"
tag:
  - build-in/all
  - list/literal
  - boolean

---

code: |
  data = [2, 4, 5, 6, {}]

  a = isinstance(data[4], dict)

  print(a)
output: "True"
tag:
  - build-in/isinstance
  - list/literal
  - dict
  - boolean  

---

code: |
  lst = [1, 2, 3, 4, 5, 6]

  a = lst[slice(0, 5, 2)]

  print(a)
output: "[1, 3, 5]"
tag:
  - build-in/slice
  - list/literal  

---

code: |
  class A:
    pass

  class B(A):
    pass


  print(issubclass(A, B))
output: "False"
tag:
  - build-in/issubclass
  - class/inheritance
  - boolean  

---

code: |
  a = divmod(1, 0)

  print(a)
output: "ZeroDivisionError: integer division or modulo by zero"
tag:
  - build-in/divmod

---

code: |
  lst = [2, 3, 4, 5]

  print(*lst, sep='!', end='?')
output: "2!3!4!5?"
tag:
  - build-in/print
  - list/literal

---

code: |
  num = float()

  print(num)
output: "0.0"
tag:
  - build-in/float

---

code: |
  vowels = ('a', 'e', 'i', 'o', 'u')

  fSet = frozenset(vowels)

  fSet.add('v')
output: "AttributeError: 'frozenset' object has no attribute 'add'"
tag:
  - build-in/frozenset
  - tuple/literal

---

code: |
  class Person:
    name = 'Petr'


  p = Person()

  setattr(p, 'name', 'Roma')

  print(p.name)
output: "Roma"
tag:
  - build-in/setattr
  - class

---

code: |
  class Student:
    marks = 10
    name = 'Vanya'


  person = Student()

  name, marks = getattr(person, 'name'), getattr(person, 'marks')

  print(name, marks)
output: "Roma"
tag:
  - build-in/getattr
  - class

---

code: |
  data = ['bread', 'milk', 'butter']

  enumerate_num = enumerate(data, 1)

  print(list(enumerate_num))
output: "Roma"
tag:
  - build-in/enumerate
  - build-in/list
  - list/literal

---

code: |
  a = 5 ** 1000000
  print(isinstance(a, int))
output: "True"
tag:
  - build-in/isinstance
  - int/pow

---
code: |
  a = bytes(range(3)).hex()

  print(a)
output: "000102"
tag:
  - byte
  - byte/operation/hex
  - build-in/range

---

code: |
  a = bytes(1)
  b = b'\x00'
  c = b'\x01'

  print(a == b)
  print(a == c)
output: "True False"
tag:
  - byte/literal
  - byte/operation/compare

---

code: |
  a = b'\x00'
  b = b'\x01'

  print(a + b)
output: "b'\\x00\\x01'"
tag:
  - byte/literal
  - byte/operation/add

---

code: |
  print(b'что выведет этот принт?')
output: "SyntaxError: bytes can only contain ASCII literal characters"
tag:
  - byte/literal

---

code: |
  a = 'a'.encode()
  b = b'a'

  print(a == b)
output: "True"
tag:
  - byte/literal
  - string/operation/encode

---
code: |
  class A:
    x = 1

  class B:
    pass

  class C(A):
    pass

  B.x = 2
  A.x = 3

  print(A.x, B.x, C.x)
output: "3 2 3"
tag:
  - class/variable

---

code: |
  from dataclasses import dataclass

  @dataclass
  class User:
    name: str
    age: int = 1

  user = User()

  print(user.age)
output: "TypeError: __init__() missing 1 required positional argument: 'name'"
tag:
  - class/dataclass

---

code: |
  class Vec:
    def __init__(self, x, y):
      self.x = x
      self.y = y

    def __add__(self, other):
      return Vec(self.x + other.x, self.y + other.y)

  a = Vec(2, 4)
  b = Vec(4, 0)

  z = a + b
  print(z.x * z.y)
output: "24"
tag:
  - class/method/__add__

---

code: |
  class A:
    def __init__(self, i):
    self.i = i

    def __eq__(self, __o: object) -> bool:
      return self.i == __o.i

  a1 = A(1)
  a2 = A(2)
  a3 = A(2)

  values = [a1, a2, a3]

  print(values.count(a2))
output: "2"
tag:
  - class/method/__eq__

---

code: |
  class MyClass:
    def __init__(self):
    self.message = 'Hello, World'


  def say_hello(self):
    print(self.message)

  MyClass.say_hello = say_hello

  a = MyClass()

  a.say_hello()
output: "Hello, World"
tag:
  - class/prototype

---

code: |
  class A():
    def __len__(self):
    return 0

  obj = A()
  print(bool(obj))
output: "False"
tag:
  - class/method/__len__

---

code: |
  class Person:
    def __init__(hey, name, age):
    hey.name = name
    hey.age = age

    def myfunc(abc):
    print("Hello my name is " + abc.name)

  p1 = Person("John", 36)
  p1.myfunc()
output: "Hello my name is John"
tag:
  - class/self

---

code: |
  class Person:
    def __init__(hey, name, age):
    hey.name = name
    hey.age = age

    def my_age(abs):
    print("Hello my name is " + abs.age)

  p1 = Person("John", 36)

  del p1.age

  p1.my_age()
output: "AttributeError: 'Person' object has no attribute 'age'"
tag:
  - statement/del
  - class/property

---

code: |
  class Person:
    def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

    def printname(self):
    print(self.firstname, self.lastname)

  class Student(Person):
    def __init__(self, fname, lname):
    super().__init__(fname, lname)

  x = Student("Mike", "Olsen")

  x.printname()
output: "Mike Olsen"
tag:
  - class/super
  - class/inheritance

---

code: |
  class Person:
    def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

    def printname(self):
    print(self.firstname, self.lastname)

  class Student(Person):
    def __init__(self, fname, lname):
    self.fname = fname
    self.lname = lname
    
  x = Student("Mike", "Olsen")

  x.printname()
output: "AttributeError: 'Student' object has no attribute 'firstname'"
tag:
  - class/super
  - class/inheritance

---

code: |
  class A(ABC):
    @abstractmethod
    def printer(self):
      print("Hello")

  class B(A):
    def __init__(self):
      pass

  a = A()
  a.printer()

  b= B()
  b.printer()
output: "Can't instantiate abstract class A with abstract methods printer"
tag:
  - class/method/abstractmethod

---

code: |
  class Vehicle:
    def __init__(self, speed):
      if speed > 240:
        print(self.speed)
      self.speed = speed

  car = Vehicle(350);
output: "AttributeError: 'Vehicle' object has no attribute 'speed' "
tag:
  - class/variable


---

code: |
  class Marks:
    def __init__(self, a, b):
      self.a =a
      self.b =b

    @staticmethod
    def Math_num():
      return self.a + self.b

  a = Marks(5, 6)
  print(a.Math_num())
output: "NameError: name 'self' is not defined "
tag:
  - class/method/staticmethod

---

code: |
  class A:
    @classmethod
    def classmethod():
      print('Class method called')

  a=A()
  a.classmethod()
output: "TypeError: classmethod() takes 0 positional arguments but 1 was given "
tag:
  - class/classmethod

---

code: |
  class A(object):
    def __init__(self):
      print("1")
  class B(A):
    def __init__(self):
      print("2")
      super().__init__()

  b = B()
output: "2 1"
tag:
  - class/method/super

---

code: |
  class Point:
    def __init__( self, x=0, y=0):
      self.x = x
      self.y = y
    def __del__(self):
      class_name = self.__class__.__name__
      print (class_name, "destroyed")

  class Pixel(Point):
    def __init__( self):
      super().__init__()

  b = Pixel()
Output: "Point destroyed Pixel destroyed"
tag:
  - class/method/del

---

code: |
  class A(object):
    foo = 1

  class B(A):
    pass

  class C(A):
    foo = 2

  class D(C, B):
    pass

  d = D()
  print(d.foo)
output: "2"
tag:
  - class/inherit

---
code: |
  class SimpleClass:
    val = 1
    def __init__(self, n):
      val = n

  s = SimpleClass(5)
  print(s.val)
output: "1"
tag:
  - class/variable

---

code: |
  class A:
    def __init__(self):
      self.x = 5
    
  class B(A):
    pass

  print(isinstance(B, A))
output: "False"
tag:
  - class/inherit #build-in/isinstance

---

code: |
  class BankCard:
    def __init__(self, x):
      self.balance = x

    def __lt__(self, other):
      return self.balance < other.balance

  card1 = BankCard(700)
  card2 = BankCard(200)
  print(card1 > card2)
output: "True"
tag:
  - class/method/lt

---
code: |
  class PersonHeight:
    def __init__(self, x):
      self.height = x

    def __gt__(self, other):
      return self.height < other.height

  height1 = PersonHeight(170)
  height2 = PersonHeight(165)
  print(height1 >= height2)
output: "TypeError: '>=' not supported between instances of 'PersonHeight' and 'PersonHeight"
tag:
  - class/method/lt

---
code: |
  class Clock:
    def __init__(self, sec):
      self.seconds = sec

    def __eq__(self, other):
      return self.seconds == other.seconds

  t1 = Clock(350)
  t2 = Clock(700)
  print(t1 != t2)
output: "True"
tag:
  - class/method/eq

---
code: |
  def double_print(func):
    def wrapper():
      func()
      func()
    return wrapper

  @double_print
  def greeting(name):
    print(f'Hello {name}', end=' ')
    
  greeting("Vladimir")
output: "TypeError: wrapper() takes 0 positional arguments but 1 was given"
tag:
  - decorator
  - function/inner

---

code: |
  def double_print(func):
    def wrapper(*args, **kwargs):
      func(*args, **kwargs)
      func(*args, **kwargs)
    return wrapper

  @double_print
  def greeting(name):
    print(f'Hello {name}', end=' ')
    
  greeting("Vladimir")
output: "Hello Vladimir Hello Vladimir"
tag:
  - decorator
  - function/inner
---
code: |
  i = {}

  print(type(i))
output: "<class 'dict'>"
tag:
  - dict/literal
  - type

---

code: |
  lst = [[1, 2], [2, 2, 3], [4, 2, 1, 1], [1, 2]]
  counts = dict()

  for el in lst:
  counts[tuple(el)] = el

  print(len(counts))
output: "3"
tag:
  - dict/operation/set

---

code: |
  nums = {
    1: {1},
    2: {2},
    3: {3}
  }

  print(list(nums.values()))
output: "[{1}, {2}, {3}]"
tag:
  - dict/operation/values

---

code: |
  template = { "i": 0 }
  values = []

  for i in range(5):
    if i > 2:
    template["i"] = i
    values.append(template)

  print(values)
output: "[{'i': 4}, {'i': 4}]"
tag:
  - dict/lvalue

---

code: |
  d = {
    -1: "some"
  }

  print(d[-1])
output: "some"
tag:
  - dict/indexing

---

code: |
  d = {
    "fruits": 3,
    "vegetables": 5,
    "cherries": 2
  }
  p = d.keys()[:]
  print(p)
output: "TypeError: 'dict_keys' object is not subscriptable"
tag:
  - dict/operation/keys

---

code: |
  element_dict = {1: 4, "value": 20, "key": 1, 18: .9}
  if any(element_dict):
    print(element_dict.keys())
output: "dict_keys([1, 'value', 'key', 18])"
tag:
  - dict/operation/keys
  - build-in/any

---

code: |
  d = {
    [1,2]: [3,4],
    (1): [1, 2]
  }
  print(d.items())
output: "TypeError: unhashable type: 'list'"

---

code: |
  dict1 = {
    0: "False",
    True: "1"
  }

  print(dict1[1], dict1[False])
output: "1 False"
tag:
  - dict/indexing

---

code: |
  text = '1,2,3'
  d = dict.fromkeys(text)

  print(len(d))
output: "4"
tag:
  - dict/operation/fromkeys

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  car.clear()

  print(car)
output: "{}"
tag:
  - dict/operation/clear

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.copy()

  print(x) 
output: "{'brand': 'Ford', 'model': 'Mustang', 'year': 1964}"
tag:
  - dict/operation/copy

---

code: |
  x = ('key1', 'key2', 'key3')
  y = 0

  value = dict.fromkeys(x, y)

  print(value) 
output: "{'key1': 0, 'key2': 0, 'key3': 0}"
tag:
  - dict/operation/fromkeys

---

code: |
  class A:
    def __init__(self, i):
    self.i = i

  x = [A(1), A(2), A(3)]
  y = 0

  value = dict.fromkeys(x, y)

  print(value)
output: "{<__main__.A object at ref>: 0, <__main__.A object at ref>: 0, <__main__.A object at ref>: 0}"
tag:
  - dict/operation/fromkeys

---

code: |
  x = [1, 2, 3]
  y = [2, 3, 5]

  value = dict.fromkeys(x, y)

  print(value)
output: "{1: [2, 3, 5], 2: [2, 3, 5], 3: [2, 3, 5]}"
tag:
  - dict/operation/fromkeys

---

code: |
  x = [ { "i": 1 }, { "i": 3 }, { "i": 2 } ]
  y = 1

  value = dict.fromkeys(x, y)

  print(value)
output: "TypeError: unhashable type: 'dict'"
tag:
  - dict/operation/fromkeys

---

code: |
  x = { 1, 2, 3 }

  value = dict.fromkeys(x)

  print(value)
output: "{1: None, 2: None, 3: None}"
tag:
  - dict/operation/fromkeys

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.get("model")

  print(x)
output: "Mustang"
tag:
  - dict/operation/get

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.get("price", 15000)

  print(x)
output: "15000"
tag:
  - dict/operation/get

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.get("price")

  print(x)
output: "None"
tag:
  - dict/operation/get

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
  }

  x = car.items()

  print(x)
output: "dict_items([('brand', 'Ford'), ('model', 'Mustang')])"
tag:
  - dict/operation/items

---

code: |
  elements = {1: 2, 2: 3, 3: 4}
  elements[2] += 6

  print(elements.items())
output: "dict_items([(1, 2), (2, 9), (3, 4)])"
tag:
  - dict/operation/item
  - dict/indexing

---

code: |
  x = {1: 'a', 2: 'b'}
  y = {2: 'c', 3: 'd'}

  print({**x, **y}[2])
output: "c"
tag:
  - dict/indexing
  - dict/var-keyword

---

code: |
  elements = [1, 2, 3]
  res_elements = dict.fromkeys(elements, elements ** 2)

  print(res_elements)
output: "TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'"
tag:
  - dict/operation/fromkeys 

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.items()

  car["year"] = 2018

  print(x)
output: "dict_items([('brand', 'Ford'), ('model', 'Mustang'), ('year', 2018)])"
tag:
  - dict/operation/items

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.keys()

  print(x)
output: "dict_keys(['brand', 'model', 'year'])"
tag:
  - dict/operation/keys

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.keys()

  car["color"] = "white"

  print(x)
output: "dict_keys(['brand', 'model', 'year', 'color'])"
tag:
  - dict/operation/keys

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  car.pop("model")

  print(car)
output: "{'brand': 'Ford', 'year': 1964}"
tag:
  - dict/operation/pop

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.pop("price")

  print(x)
output: "KeyError: 'price'"
tag:
  - dict/operation/pop

---

code: |
  car = {
    "brand": "Ford",
    "year": 1964
  }

  x = car.pop("model", 'Rover')

  print(x)
output: "Rover"
tag:
  - dict/operation/pop

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.popitem()

  print(x)
output: "('year', 1964)"
tag:
  - dict/operation/popitem

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.setdefault("model", "Bronco")

  print(x)
output: "Mustang"
tag:
  - dict/operation/setdefault

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.setdefault("color", "white")

  print(x)
output: "white"
tag:
  - dict/operation/setdefault

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  x = car.setdefault("price")

  print(x)
output: "None"
tag:
  - dict/operation/setdefault

---

code: |
  car = {
    "brand": "Ford",
    "model": "Mustang",
    "year": 1964
  }

  car.update({"color": "White"})

  print(car)
output: "{'brand': 'Ford', 'model': 'Mustang', 'year': 1964, 'color': 'White'}"
tag:
  - dict/operation/update

---
code: |
  print(print('hi!'))
output: "hi! None"
tag:
  - expression/priority

---

code: |
  def get_username(user):
    return user or 'anonymous'

  print(get_username(None))
output: "anonymous"
tag:
  - expression/operation/or

---

code: |
  print(1.5 % 1)
output: "0.5"
tag:
  - expression/operation/modulo

---

code: |
  a = None
  b = False

  print((a or b) or a)
output: "None"
tag:
  - expression/operation/or

---

code: |
  print(bool(print(print(5))))
output: "5 None False"
tag:
  - expression/priority

---

code: |
  print(type( 3.4 // 2 ))
output: "<class 'float'>"
tag:
  - expression/integer_division

---

code: |
  sum = lambda x, y: x + y
  print(sum(2,4))
output: "6"
tag:
  - expression/lambda

---

code: |
  print(False == (not True))
output: "True"
tag:
  - expression/operation/not

---

code: |
  a = 0
  b = 1

  print(a and (b / a) >= 0)
output: "0"
tag:
  - expression/operation/and
  - expression/evaluation_order

---

code: |
  a = 0.1 + 0.2
  
  print(a == float(0.3))
output: "False"
tag:
  - expression/operation/equality

---

code: |
  m = 300
  count = 0
  while m <= 305:
    m = m + 1
    if m % 2 != 0:
    continue
    count += 1

  print(count)
output: "3"
tag:
  - expression/operation/modulo

---

code: |
  number = 0
  list = [2, 3, 4, 5]
  num = 5 % 2

  if num not in list:
    number = 1

  print(number)
output: "1"
tag:
  - expression/operation/not_in
  - list

---

code: |
  number = 0
  str = 'I love Python'
  letter = 'l'

  if letter in str:
    number = 1
  
  print(number)
output: "1"
tag:
  - expression/operation/in
  - string

---

code: |
  data = {"age": 30, "name": "Bob"}

  print("age" in data)
output: "True"
tag:
  - expression/operation/in
  - dict

---

code: |
  a = "2"
  b = 2
  c = type(b)

  if c(a) is b:
    print("True")
  else:
    print("False")
output: "True"
tag:
  - expression/operation/is
  - type

---

code: |
  number = 0
  list = [2, 3, 4, 5]
  num = 5 ** 2

  if num not in list:
    number = 1
  
  print(number)
output: "1"
tag:
  - expression/operation/power

---
code: |
  a = 0.1 + 0.2

  print(a == float('0.3'))
output: "False"
tag:
  - float/operation/compare

---

code: |
  for x in range(10):
    if (x/3).is_integer():
      print(x)
output: "0 3 6 9"
tag:
  - float/operation/is_integer

---

code: |
  print(0.5.as_integer_ratio())
output: "(1, 2)"
tag:
  - float/operation/as_integer_ratio

---

code: |
  print(0.9.as_integer_ratio())
output: "(8106479329266893, 9007199254740992)"
tag:
  - float/operation/as_integer_ratio

---

code: |
  n = 6.732894256771

  print(f"{n:.4f}" == f"{round(n, 4)}")
output: "True"
tag:
  - float/round
  - build-in/round

---

code: |
  a = f"{2e-3 + 0.001 - 1}"

  print(len(a))
output: "6"
tag:
  - float
  - build-in/len

---

code: |
  print(9**19 - int(float(9**19)) > 0)
output: "True"
tag:
  - build-in/int
  - build-in/float
  - int/operator/exponentiation

---

code: |
  print(round(0.5))
output: "0"
tag:
  - float/operation/round

---
code: |
  a = 5 ** 1000000
  b = 5. ** 1000000

  print(type(a) == type(b))
output: "OverflowError: (34, 'Result too large')  "
tag:
  - float/comprehension
  - build-in/type

---
code: |
  def func(*args):
    args.append(3)
    print(*args)

  func(1,2)
output: "AttributeError: 'tuple' object has no attribute 'append'"
tag:
  - function/parameter
  - tuple/operation

---

code: |
  mult_value = 2
  lst = [2, 5, 11, 9]

  iterator = map(lambda x: x * mult_value, lst)

  mult_value = 1
  lst = [1, 4, 10, 8]

  print(*list(iterator))
output: "2 5 11 9"
tag:
  - function/lambda/closures

---

code: |
  print((lambda x : x ** 3)((lambda x : x + 2)(1)))
output: "27"
tag:
  - function/lambda

---

code: |
  def calc_sum(*args, **kwargs):
    return sum(args, kwargs)

  print(calc_sum(1, 2, a = 3, b = 4))
output: "TypeError: unsupported operand type(s) for +: 'dict' and 'int'"
tag:
  - function/parameter/unpacking

---

code: |
  def a(a):
    def b():
      print(a)

  a(4)()
output: "TypeError: 'NoneType' object is not callable"
tag:
  - function/inner_function

---

code: |
  def quatro(*x):
    x.append(x)
    return x

  print(quatro(1, 2, 3))
output: "AttributeError: 'tuple' object has no attribute 'append'"
tag:
  - function/parameter/unpacking

---

code: |
  def foo(value = []):
    value.append('some')
    return value

  values = []
  for i in range(3):
    values.append(foo())

  print(values)
output: "[['some', 'some', 'some'], ['some', 'some', 'some'], ['some', 'some', 'some']]"
tag:
  - function/parameter/default

---

code: |
  def func(n):
    return lambda a : a * n

  doubler = func(2)

  print(type(doubler))
output: "<class 'function'>"
tag:
  - function/lambda
  - build-in/type

---

code: | 
  print(lambda: True)
output: "True"
tag:
  - function/lambda

---

code: |
  def func():
    pass

  print(func())
output: "None"
tag:
  - function

---

code: |
  def func(**kwargs):
    return kwargs

  test = func(a=1, b=2, c=3)

  print(test)
output: "{'a': 1, 'c': 3, 'b': 2}"
tag:
  - function
  - build-in/dict

---

code: |
  def func(**kwargs):
    return kwargs

  print(func())
output: "{}"
tag:
  - function
  - build-in/dict

---

code: |
  def outer(num):
    def inner(num1):
      return num + num1
    return inner

  otr = outer(100)

  print(otr(200))
output: "300"
tag:
  - function/inner

---

code: |
  def func(*args):
    return args

  test = func(1, 2, 3, 'abc')

  print(test)
output: "(1, 2, 3, 'abc')"
tag:
  - function
  - build-in/tuple

---

code: |
  def func(*args):
    return args
    
  print(func())
output: "()"
tag:
  - function
  - build-in/tuple

---
code: |
  def func():
    yield 1
    return 2
    yield 3

  for i in func():
    print(i)
output: "1"
tag:
  - generator/definition
  - iterator

---

code: |
  a = [1, 5, 14]

  gen = (i * 2 for i in a)
  b = list(gen)

  print(*gen)
output: "''"
tag:
  - generator/reusable

---

code: |
  num_list: list = [1, 3, 6, 10]
  multiplied_list = (num**2 for num in num_list)

  print(type(multiplied_list))
output: "<class 'generator'>"
tag:
  - generator
  - build-in/list
  - build-in/type

---

code: |
  numbers = [1, 2, 3, 4, 5]
  squares: list = [number**2 for number in numbers if number % 2 == 0]

  print(squares)
output: "[4, 16]"
tag:
  - generator
  - build-in/list

---

code: |
  def increment(n):
    yield n + 1
    
  print(type(increment(5)))
output: "<class 'generator'>"
tag:
  - generator
  - build-in/yield
  - build-in/type

---

code: |
  def func():
    yield 'Hello'
    yield 'World'
    yield '!!!'
    
  for letter in func():
    print(letter, end=' ')
output: "Hello World !!!"
tag:
  - generator
  - build-in/yield

---

code: |
  expression = (letter for letter in 'abc')
  len(expression)
output: "TypeError: object of type 'generator' has no len()"
tag:
  - generator
  - build-in/len

---

code: |
  abc_gen_expr = (letter for letter in 'abc')

  print(next(abc_gen_expr))
output: "a"
tag:
  - generator
  - build-in/next

---
code: |
  a, b = 3, 4

  print(a.bit_length(), b.bit_length())
output: "2 3"
tag:
  - int/operation/bit_length
  - int/literal

---

code: |
  a, b = 3, 4

  print(a.bit_count(), b.bit_count())
output: "2 1"
tag:
  - int/operation/bit_count
  - int/literal

---

code: |
  a = 1 - .1

  print(int(a))
output: "0"
tag:
  - int
  - build-in/int

---

code: |
  a, b = 424411453, 3122871
  lst = divmod(a, b)
  res = lst[0] * b + lst[1]

  print(res == a)
output: "2 1"
tag:
  - int/operation/divmod
  - int/literal

---

code: |
  a = 0
  for x in range(5):
    a -= -abs(-x)
    
  print(a)
output: "10"
tag:
  - int/operation/abs
  - int/operation/negation

---

code: |
  print(pow(2, 3, 3))
output: "2"
tag:
  - int/operation/modular_exponentiation

---

code: |
  a = str(bin(4))
  b = str(bytes(4))

  print(a == b)
output: "False"
tag:
  - int/operation/bin
  - build-in/bytes
  - build-in/str

---
code: |
  a = 101 ** 100
  b = 95. ** 100

  print(type(a) == type(b))
output: "False"
tag:
  - int/operation/pow
  - float/operation/pow
  - build-in/type

---
code: |
  numbers = [100, 200, 300]
  iterator = iter(numbers)

  print(len(iterator))
output: "TypeError: object of type 'list_iterator' has no len()"
tag:
  - iterator
  - build-in/len

---

code: |
  numbers = [100, 200, 300]
  iterator1 = iter(numbers)
  iterator2 = iter(iterator1)

  print(iterator1 is iterator2)
output: "True"
tag:
  - iterator

---

code: |
  def custom_chain(*iterables):
    for iterable in iterables:
      yield from iterable
  
  for x in custom_chain([1, 2, 3], 'abc'):
    print(x, end=' ')
output: "1 2 3 a b c"
tag:
  - iterator
  - build-in/yield

---

code: |
  scores: dict = {'John': 99, 'Danny': 95}

  iter_scores = iter(scores)

  print(type(iter_scores))
output: "<class 'dict_keyiterator'>"
tag:
  - iterator #build-in/dict

---

code: |
  def custom_chain(*iterables):
    for iterable in iterables:
      yield from iterable
  
  for x in custom_chain([1, 2, 3], 'abc'):
    print(x, end=' ')
output: "1 2 3 a b c"
tag:
  - iterator
  - build-in/yield

---

code: |
  scores: dict = {'John': 99, 'Danny': 95}
  iter_scores = iter(scores)

  print(type(iter_scores))
output: "<class 'dict_keyiterator'>"
tag:
  - iterator
  - build-in/type
  - build-in/dict
---
code: |
  lst = [2,4]

  print(lst * 2 / 2)
output: "TypeError: unsupported operand type(s) for /: 'list' and 'int'"
tag:
  - list/operation

---

code: |
  num = 32 // 3
  phrase = 'Hello' if num == 10 else 'World'

  print('-'.join(phrase[::-1]))
output: "o-l-l-e-H"
tag:
  - list/operation/slice
  - string/operation/join

---

code: |
  lst_1 = [1, 2, 3, 4, 5]
  lst_2 = lst_1[:2]
  lst_1[2:] = lst_2[:]

  print(lst_1, end=" ")
  print(lst_2)
output: "[1, 2, 1, 2] [1, 2]"
tag:
  - list/operation/slice

---

code: |
  x1 = [i for i in range(10) if i % 2 and i % 3]
  x2 = x1
  x2.append(e for e in range(8) if e not in x1)

  print(x1)
output: "[1, 5, 7, <generator object <genexpr> at 0x7f18ad923f40>]"
tag:
  - list/comprehension
  - build-in/append
  - build-in/range
  - generator

---

code: |
  x1 = [17, 33, 15, 6, 1, 14]
  x2 = []
  while (el := x1.pop()) >= 15:
    x2.append(el)

  print(x2)
output: "[14, 1, 6, 15]"
tag:
  - list/operation/pop

---

code: |
  lst = ["ab", "vm"]
  for x in lst:
    lst.append(x.upper())

  print(lst)
output: "Infinite loop."
tag:
  - list/operation/append
  - string/operation/upper

---

code: |
  lst1 = [2, 5, 8, 0, 4, 1]
  lst2 = lst1

  print(lst1 is lst2, lst1 == lst2)
output: "True True"
tag:
  - list
  - expression/operation/is
  - expression/operation/equality

---

code: |
  lst1 = [2, 5, 8, 0, 4, 1]
  lst2 = lst1[:]

  print(lst1 is lst2, lst1 == lst2)
output: "False True"
tag:
  - list/operation/slice
  - expression/operation/is
  - expression/operation/equality

---

code: |
  lst1 = [2, 5, 8, 0, 4, 1]
  lst2 = lst1.copy()

  print(lst1 is lst2, lst1 == lst2)
output: "False True"
tag:
  - list/operation/copy
  - expression/operation/is
  - expression/operation/equality

---

code: |
  furniture_1 = ["TV", "Projector", "Playstation"]
  furniture_2 = ["Fridge", "Cooker", "Toster"]

  furniture_1.extend(furniture_2)
  furniture_2.append(furniture_1)

  print(furniture_2)
output: "['Fridge', 'Cooker', 'Toster', ['TV', 'Projector', 'Playstation', 'Fridge', 'Cooker', 'Toster']]"
tag:
  - list/operation/extend
  - list/operation/append

---

code: |
  furniture = ['TV', 'Projector', 'Playstation', 'Fridge', 'Cooker', 'Toster']
  furniture.reverse()

  print(*furniture[::-1])
output: "'TV' 'Projector' 'Playstation' 'Fridge' 'Cooker' 'Toster'"
tag:
  - list/operation/reverse
  - list/operation/slice

---

code: |
  row_data = ["False", 1076, [], True, 13 - 5, ("Vancouver", "Helsinki", "Montreal"), "trust", {56.22, "12"}]
  row_data.sort(reverse=True)

  print(row_data)
output: "TypeError: '<' not supported between 'int' and 'str'"
tag:
  - list/operation/sort

---

code: |
  lst = [15 + 6, 24 // 3, True == False, 12 - 3 - 3, 7 + 5 // 4]
  lst.sort(key=lambda x: x > 10)

  print(set(lst))
output: "{8, False, 21, 6}"
tag:
  - list/operation/sort
  - build-in/set

---

code: |
  lst = ["Jake", "Mike", "Brien", "Tim", "George", "Heisenberg"]
  lst.sort(key=lambda x: len(x), reverse=True)

  print(lst)
output: "['Heisenberg', 'Brien', 'George', 'Jake', 'Mike', 'Tim']"
tag:
  - list/operation/sort

---

code: |
  lst = [(25, 48, 254), {17, 32, 54.54}, [125, 91], [4.03], (77.78,), {.0299}, {41.7, 33, 49, 55}]
  lst.sort(key=lambda x: max(x))

  print(lst)
output: "[{0.0299}, [4.03], {32, 17, 54.54}, {41.7, 33, 55, 49}, (77.78,), [125, 91], (25, 48, 254)]"
tag:
  - list/operation/sort

---
code: |
  a = ["Jake", "Mike", "Brien", "Tim", "George", "Heisenberg"]
  a.insert("Kenny", 14)

  print(a)
output: "TypeError: 'str' object cannot be interpreted as an integer"
tag:
  - list/operation/insert

---
code: |
  a = ["Jake", "Mike", "Brien", "Heisenberg"]
  a.insert(14, "Kenny")

  print(a)
output: "['Jake', 'Mike', 'Brien', 'Heisenberg', 'Kenny']"
tag:
  - list/operation/insert

---
code: |
  a = 1.2
  b = a - 0.2
  lst = [1.2, 0.2]

  print(a, lst[b])
output: "TypeError: list indices must be integers or slices, not float"
tag:
  - list/literal

---

code: |
  a = [1]
  a.insert(4, 3)

  print(a)
output: "[1, 3]"
tag:
  - list/operation/insert

---

code: |
  a = list(range(6))
  a[2:10] = []

  print(a)
output: "[0, 1]"
tag:
  - list/operation/slice

---

code: |
  a = sorted([1, 4, 6, 10])
  b = [1, 4, 6, 10].sort()

  print(a == b)
output: "False"
tag:
  - list/operation/compare

---

code: |
  a = (0)
  b = [0], [[0]], {0}, [(0)]

  for i in b:
    print(a in i)
output: "True False True True"
tag:
  - list/operation/in

---

code: |
  obj1 = { "1": 1 }
  obj2 = { "2": 1 }
  obj3 = { "1": 1 }
  values = [obj1, obj2, obj3]

  print(values.count(obj1))
output: "2"
tag:
  - list/operation/count
  - dict/equal

---

code: |
  k = [7, 15, 13, 9, 1, 6, 13, 10, 2, 1, 0, 0.1, 4]

  print(k.count(13 | 4))
output: "2"
tag:
  - list/operation/count

---

code: |
  lst = ['123', '321', '000']

  print(lst.pop(2), *lst)
output: "000 123 321"
tag:
  - list/operation/pop

---
---
code: |
  a = [[] * 2] * 2
  a[0].append(1)

  print(a)
output: "[[1], [1]]"
tag:
  - object/reference
  - list/operation/append
  - list/operation/multiply, 

---

code: |
  a = [[0]*2]*2
  a[0][0] = 5

  print(a)
output: "[[5, 0], [5, 0]]"
tag:
  - object/reference
  - list/operation/multiply

---

code: |
  a = [1, 2, 3]
  b = a[:]

  print(a == b, id(a) == id(b))
output: "True False"
tag:
  - object/identify

---

code: |
  a = [2, 4, 3]
  b = sorted(a)
  b.insert(0, 1)

  print(a[0])
output: "2"
tag:
  - object/reference

---

code: |
  def f(a, x):
    return a.x + x

  class Obj:
    def f(self, x):
      self.x = x
      return x + 2

  obj = Obj()

  print(f(obj, obj.f(2)))
output: "6"
tag:
  - object/variable

---

code: |
  a = 4
  b = a
  del a
  a = 2

  print(b == 2)
output : "False"
tag:
  - object/reference

---

code: |
  class ABC:
    def __repr__(self):
      return 'abc'
    
    def __str__(self):
      return 'abc'

  a = 'abc'
  b = ABC()

  print(a == b)
output: "False"
tag:
  - object/compare

---

code: |
  class A:
    def __init__(self, name):
      self.__name = name

    def greeting(self):
      print(self.__name)

  class B(A):
    def __init__(self):
      pass
    
  b = B("Anton")
  b.greeting()
output: "NameError: name 'Anton' is not defined"
tag:
  - object/variable

---

code: |
  class A:
    def __init__(self, name):
      __name = name

    def greeting(self):
      print(__name)

  a = A("Anton")
  a.greeting()
output: "AttributeError: name '_A__name' is not defined"
tag:
  - object/variable

---

code: |
  class B:
    def __printer(self):
      print("Hello")

  b = B()
  b.__printer()
output: "AttributeError: 'B' object has no attribute '__printer'"
tag:
  - object/access_identifier

---

code: |
  class Soda:
    def __init__(self, ingredient):
      self.ingredient = ingredient if isinstance(ingredient, str) else None

    def show_my_drink(self):
      if self.ingredient:
        print(f'Soda and {self.ingredient}')
      else:
        print('Regular soda')

  drink1 = Soda('raspberry')
  drink2 = Soda(5)
  print(drink1.show_my_drink(), drink2.show_my_drink())
output: "Soda and raspberry Regular soda None None"
tag:
  - object/variable

---

code: |
  a = [5, 3, []]
  b = [5, 3, []]

  print(a[-1] is b[-1])
output: "False"
tag:
  - object/identify

---

code: |
  x = ["name", "id", "balance", "date"]
  x1 = x[:]
  x2 = x.copy()

  print(x1 == x2, x1 is x2)
output: "True False"
tag:
  - object/compare #object/identify

---

code: |
  h = "Hola"
  el1 = set(h)
  el2 = set(h)

  print(el1 is el2)
output: "False"
tag:
  - object/identify

---

code: |
  class Test:
    test = 5

    def init(self, test):
      self.test = test

  obj = Test(5)

  print(Test.test is obj.test)
output: "TypeError: Test() takes no arguments"
tag:
  - object/identify
---
code: |
  def foo():
    x = 1
    return x

  foo.x = 4

  print(foo(), foo.x)
output: "1 4"
tag:
  - scope
  - object/variable
  - function/variable
  - function/object

---

code: |
  def foo():
    x = 300
    def foo2():
    print(x)
    foo2()

  foo() 
output: "300"
tag:
  - scope

---

code: |
  x = 300

  def foo():
    return x

  print(foo() == x)
output: "True"
tag:
  - scope
  - boolean/operation/compare

---

code: |
  x = 300

  def foo():
    x = 200
    return x

  print(foo(), x)
output: "200 300"
tag:
  - scope

---

code: |
  def foo():
    global x
    x = 300

  foo()

  print(x)
output: "300"
tag:
  - scope
  - statement/global

---

code: |
  x = 300

  def foo():
    global x
    x = 200

  foo()

  print(x) 
output: "200"
tag:
  - scope
  - statement/global

---

code: |
  def foo():
    x = 12
    def foo2(a):
    x += a
    return x
    return foo2

  fun = foo()

  print(fun(2))
output: "UnboundLocalError: local variable 'x' referenced before assignment"
tag:
  - scope

---
code: |
  num = 2

  def increment():
    nonlocal num
    num = num + 1
    print(num)

  increment()
output: "SyntaxError: no binding for nonlocal 'num' found"
tag:
  - scope/nonlocal

---

code: |
  def func(): 
    print(name, end = ' ')
    name = "Anton"
    print(name)

  name = "Petr"
  func()
output: "UnboundLocalError: local variable 'name' referenced before assignment"
tag:
  - scope

---

code: |
  name = 'Anton'

  def greeting():
    name = 'Rob'
    print(f'Hello {name}', end = ' ')

  def farewell():
    print(f'Bye {name}')

  greeting()
  farewell()
output: "Hello Rob Bye Anton"
tag:
  - scope

---

code: |
  name = 'Tom'

  def greeting():
    global name
    name = 'Bob'
    print(f'Hello {name}', end = ' ')

  def farewell():
    print(f'Bye {name}')

  greeting()
  farewell()
output: "Hello Bob Bye Bob"
tag:
  - scope/global

---

code: |
  def outer():
    num = 5

    def inner():
      nonlocal num
      num = 25
      print(num, end = ' ')

    inner()
    print(num)

  outer()
output: "25 25"
tag:
  - scope/nonlocal
  - function/inner

---

code: |
  def outer():
    def inner():
      nonlocal num
      num = 25
      print(num, end = ' ')

    inner()
    print(num)

  outer()
output: "SyntaxError: no binding for nonlocal 'num' found"
tag:
  - scope/nonlocal
  - function/inner

---

code: |
  def outer():
    num = 5

    def inner():
      global num
      num = 25
      print(num, end = ' ')

    inner()
    print(num)

  outer()
output: "25 5"
tag:
  - scope/global
  - function/inner

---

code: |
  num = 2

  def increment():
    num = num + 1
    print(num)

  increment()
output: "UnboundLocalError: local variable 'num' referenced before assignment"
tag:
  - scope

---

code: |
  num = 2

  def increment():
    global num
    num = num + 1
    print(num)

  increment()
output: "3"
tag:
  - scope/global

---

code: |
  def outer():
    num = 5

    def inner():
      num = 25
      print(num, end = ' ')

    inner()
    print(num)

  outer()
output: "25 5"
tag:
  - scope
  - function/inner

---
code: |
  a = {1, True, '1'}

  print(len(a))
output: "2"
tag:
  - set/literal
  - set/operation/length

---

code: |
  words = {'user', 'billy',
      'password', 'text'}

  print(words['password'])
output: "TypeError: 'set' object is not subscriptable"
tag:
  - set/operation

---

code: |
  lst1 = [x for x in range(6)]
  lst2 = [y for y in range(9)]
  a = lst1 + lst2

  print(*a)
output: "0 1 2 3 4 5 6 7 8"
tag:
  - set
  - list/comprehension
  - build-in/set

---

code: |
  s1 = {1, 2, 3, 4, 5}
  s2 = {3, 4, 5}

  print(len(s2 - s1))
output: "0"
tag: 
  - set/operation/difference

---

code: |
  a = {1, 2, 3, 4, 5}
  b = {1, 2, 3, 4, 5}

  print(b.issuperset(a))
output: "True"
tag: 
  - set/operation/issuperset

---

code: |
  a = {1, 2, 3}
  b = {1, 2, 3, 4, 5}

  print(a & b | a)
output: "{1, 2, 3}"
tag:
  - set/operation/definition
  - set/operation/addition

---

code: |
  a = {1, 2, 3, 4, 5}
  b = {1, 2, 3}

  print(a | b & a)
output: "{1, 2, 3, 4, 5}"
tag:
  - set/operation/definition
  - set/operation/addition

---

code: |
  a = {5, 4, 3, 2, 1}
  b = {1, 2, 3, 6}
  c = {7, 4, 2, 1}
  c = c.union(a & b)

  print(c)
output: "{1, 2, 3, 4, 7}"
tag:
  - set/operation/union
  - set/operation/definition

---

code: |
  a = {5, 4, 3, 2, 1}
  b = {1, 2, 3, 6}
  c = {7, 4, 2, 1}
  c = c.symmetric_difference(a | b)

  print(c)
output: "{3, 5, 6, 7}"
tag:
  - set/operation/symmetric_difference
  - set/operation/addition

---

code: |
  shop_list1 = {"apple", "cheese", "milk", "yogurt", "juice"}
  shop_list2 = {"banana", "coffee", "cacao", "milk", "tomato", "cheese"}

  print(*shop_list1.intersection(shop_list2))
output: "'milk' 'cheese'"
tag:
  - set/operation/intersection

---

code: |
  shop_list1 = {"apple", "cheese", "milk", "yogurt", "juice"}
  shop_list2 = {"banana", "coffee", "cacao", "milk", "tomato", "cheese"}
  shop_list1.intersection_update(shop_list2)

  print(shop_list1)
output: "{'milk', 'cheese'}"
tag:
  - set/operation/intersection_update

---

code: |
  lang1 = {"C++", "C", "C#", "Java", "Perl"}

  lang2 = lang1.copy()
  lang2.update(
    ["C", "Python", "C++",  "JavaScript", "PHP"]
  )

  print(*lang2.difference(lang1))
output: "'JavaScript' 'PHP' 'Python'"
tag:
  - set/operation/difference
  - set/operation/update

---

code: |
  lang1 = {"C++", "C", "C#", "Java", "Perl"}
  lang2 = ["C", "Python", "C++",  "JavaScript", "TypeScript", "PHP"]

  print(lang1.isdisjoint(lang2))
output: "False"
tag:
  - set/operation/isdisjoint

---

code: |
  cities1 = {"New York", "Toronto", "Cape Town", "Sao Paulo"}
  cities2 = {"Istanbul", "New York", "Caracas", "Cape Town"}
  
  print(cities2.symmetric_difference(cities1))
output: "{'Toronto', 'Caracas', 'Istanbul', 'Sao Paulo'}"
tag:
  - set/operation/symmetric_difference

---

code: |
  a = {3, 2, 1}
  b = {1, 2, 3}

  print(a.union(b).index(3))
output: "AttributeError: 'set' object has no attribute 'index'"
tag:
  - set/operation/union 

---

code: |
  a = set("Hello")

  print(a[-1::-1])
output: "TypeError: 'set' object is not subscriptable"
tag:
  - set

---

code: |
  a = {el for el in "bacb-bd77-1abd-ac8b" if not el.isdigit()}

  print(a)
output: "{'-', 'b', 'c', 'd', 'a'}"
tag:
  - set/comprehension

---

code: |
  ids = {1, 2, 3, 4, 3}

  print(ids[2])
output: "TypeError: 'set' object is not subscriptable"
tag:
  - set/comprehension

---

code: |
  lst = [1, 'non-empty string', True, '', False, 0, None]
  st = set(lst)

  print(len(st))
output: "5"
tag:
  - set/comprehension
  - boolean/literal

---

code: |
  fruits = {"apple", "banana", "cherry"}
  fruits.add("orange")

  print(fruits)
output: "{'orange', 'apple', 'cherry', 'banana'}"
tag:
  - set/operation/add

---

code: |
  fruits = {"apple", "banana", "cherry"}
  fruits.add("banana")

  print(fruits)
output: "{'cherry', 'banana', 'apple'}"
tag:
  - set/operation/add

---

code: |
  fruits = {"apple", "banana", "cherry"}
  fruits.clear()

  print(fruits)
output: "set()"
tag:
  - set/operation/clear

---

code: |
  fruits = {"apple", "banana", "cherry"}
  fruits.remove("orange")

  print(fruits) 
output: "KeyError: 'orange'"
tag:
  - set/operation/remove

---

code: |
  fruits = {"apple", "banana", "cherry"}
  fruits.discard("orange")

  print(fruits)
output: "{'apple', 'banana', 'cherry'}"
tag:
  - set/operation/discard

---
code: |
  a, *b, c = [1, 2, 3, 4, 5]

  print(a, b, c)
output: "1 [2, 3, 4] 5"
tag:
  - statement/assignment

---

code: |
  a, *b, c = [1, 2]

  print(a, b, c)
output: "1 [] 2"
tag:
  - statement/assignment
 
---

code: |
  word1 = 'welcome'
  word2 = 'home'
  r = list()

  for x in word1:
    for x in word2:
      r.append(x)

  print(r[2] + r[1] + r[2])
output: "mom"
tag:
  - statement/for

---

code: |
  a = [1, 2, 3]
  b = a
  del a

  print(b)
output: "[1, 2, 3]"
tag:
  - statement/del

---

code: |
  numbers = [2, 3, 1, -2, 0]

  for i in enumerate(numbers):
    if i[0] == 0:
      if i[1] == 0:
        print(i)
    else:
      continue

  print(i)
output: "(4,0)"
tag:
  - statement/for
  - build-in/enumerate

---

code: |
  a = [0, 2, -4, -2, 1]

  for i in a:
    if i < 0:
      a.append(abs(i))
    x = i

  print(x)
output: "2"
tag:
  - statement/for

---

code: |
  a = 0

  for i in range(10):
    if i == 0:
      a = 13
    else:
      a =- 1

  print(a)
output: "-1"
tag:
  - statement/for

---

code: |
  try:
    raise IndexError
  except IndexError:
    print("Получаем исключение")
  else:
    print("Ловим его")
output: "Получаем исключение"
tag:
  - statement/try

---

code: |
  def f():
    try: 
      return 1
    finally:
      return 2

  print(f())
output: "2"
tag:
  - statement/try

---

code: |
  a = {(13, 3), "qwer", 67, 1, 5, 33, 2, 7, "youths"}
  b = ["python"]

  for el in a:
    b.append(el)
  else:
    a.union(b)
    
  print(a)
output: "{1, 2, 67, 33, 5, 'python', 7, (13, 3), 'youths', 'qwer'}"
tag:
  - statement/for

---

code: |
  lst = [15, 30, 11, 12, 9, 0, 6, 4, 12, 13]
  free_list = ["free list"]
  last_element = 0
  n = 0

  while not any(free_list):
    free_list.append(lst[n])
    n += 1
  else:
    last_element = free_list.pop()
    
  print(last_element)
output: "'free list'"
tag:
  - statement/while

---

code: |
  def foo(value):
    num = 12
    try:
    num //= value
    except:
    num = 3
    else:
    num = 4
    finally:
    num = 5
    return num

  print(foo(0))
output: "5"
tag:
  - statement/try,  #statement/try/else
  - statement/try/finally

---

code: |
  count = 0
  for letter in 'foo':
    count+=1
  else:
    print(count)
output: "3"
tag:
  - statement/for/else

---

code: |
  def foo(value):
    num = 12
    try:
    num //= value
    except:
    num = 3
    else:
    num = 4
    return num

  print(foo(4))
output: "4"
tag:
  - statement/try
  - statement/try/else

---

code: |
  numbers = [10, 40, 120, 230]
  for i in numbers:
    if i > 100:
      print(i)
      break
output: "120"
tag:
  - statement/break

---

code: |
  assert "hello, world" is True
output: "AssertionError"
tag:
  - statement/assert
  - expression/operation/is
  - boolean/literal

---

code: |
  x = 10
  y = 30
  del x, y

  print(x, y)
output: "NameError: name 'x' is not defined"
tag:
  - statement/del

---

code: |
  value = True
  assert value == True 
output: "''"
tag:
  - statement/assert
  - boolean/literal,  #boolean/operation/compare

---

code: |
  def user_check(choice):
    if choice == 1:
      print("Admin")
    elif choice == 2:
      print("Editor")
    elif choice == 3:
      print("Guest")
    else:
      print("Wrong entry")

  user_check(4)
output: "Wrong entry"
tag:
  - statement/if

---

code: |
  num = 10
  sum = 0
  i = 1
  while i <= num:
    sum = sum + i
    i = i + 1

  print(sum)
output: "55"
tag:
  - statement/while

---

code: |
  try:
    print(1 / 0)
  except:
    raise RuntimeError("Something bad happened")
output: "ZeroDivisionError: division by zero"
tag:
  - statement/raise
  - statement/try

---

code: |
  import math as m

  print(m.sqrt(64))
output: "8.0"
tag:
  - statement/as
  - statement/import

---

code: |
  numbers = [2, 3, 11, 7]
  for i in numbers:
    if i > 10:
      continue
    square = i * i

  print(square)
output: "49"
tag:
  - statement/continue

---

code: |
  odd = [1, 5, 7, 9]
  even = [i + 1 for i in odd if i % 2 == 1]

  print(even[2])
output: "8"
tag:
  - statement/for

---

code: |
  a, b = 1, 0
  count = 0

  try:
    print(a/b)
  except ZeroDivisionError:
    count += 1
  else:
    count += 2
  finally:
    count += 3

  print(count)
output: "4"
tag:
  - statement/try/except

---

code: |
  def numbers_range(n):
    for i in range(n):
      yield i
  
  a = numbers_range(4)

  print(next(a))
output: "0"
tag:
  - statement/yield
  - generator/definition

---

code: |
  value = True
  if value is not False:
    print("False")
  else:
    print("True")
output: "False"
tag:
  - statement/not
  - statement/is
  - boolean/literal

---

code: |
  def get_even(numbers):
    return [num for num in numbers if not num % 2]

  print(len(get_even([1, 2, 3, 4, 5, 6])))
output: "3"
tag:
  - statement/return

---

code: |
  x = "hello"

  if not type(x) is int:
    raise TypeError("Only integers are allowed")
output: "TypeError: Only integers are allowed"
tag:
  - statement/raise

---

code: |
  values = []

  for i in range(10):
    if i < 4:
    continue
    values.append(i)

  print(values)
output: "[4, 5, 6, 7, 8, 9]"
tag:
  - statement/for
  - statement/continue
  - expression/operation/smaller

---

code: |
  idx = 15
  msg = 'message'
  if idx % 15 == 0:
    pass
  elif idx % 5 == 0:
    msg = 'Buzz'
  else:
    pass

  print(msg)
output: "message"
tag:
  - statement/pass

---

code: |
  def foo():
    x = 20

    def bar():
      global x
      x = 25
    bar()

  foo()

  print(x)
output: "25"
tag:
  - statement/global

---
code: |
  a = 'Python best'
  a[a.index('t')] = 'd'

  print(a)
output: "TypeError: 'str' object does not support item assignment"
tag:
  - string/immutable

---

code: |
  print(sum('Lorem ipsum', ''))
output: "TypeError: sum() can't sum strings [use ''.join(seq) instead]"
tag:
  - string/concatenation
  - built-in/sum

---

code: |
  a = "Hello, World"

  print(a[:6:2])
output: "Hlo"
tag:
  - string/operation/slice

---

code: |
  st = "spam"

  print(st[:-1:])
output: "spa"
tag:
  - string/operation/slice

---

code: |
  st = "spam"

  print(st[-1::-1])
output: "maps"
tag:
  - string/operation/slice

---

code: |
  print("abbzxyzxzxabb".count("abb", -10, -1))
output: "0"
tag:
  - string/operation/count

---

code: |
  arr = (1, 2, 3)
  s = str(arr)

  print(s[4:10])
output: "2, 3)"
tag:
  - string/operation/slice
  - build-in/str

---

code: |
  s = "python"

  print(len(s * 2 + ''))
output: "12"
tag:
  - string/operation/multiple
  - build-in/len

---

code: |
  a = "Good morning!"
  b = a.zfill(20)
  if b != a:
    print(a, b)
output: "'Good morning!' '0000000Good morning!'"
tag:
  - string/operation/zfill

---

code: |
  txt = "For only {price:.2f} dollars!"

  print(txt.format(price=49)) 
output: "For only 49.00 dollars!"
tag:
  - string/operation/format

---

code: |
  s = "Python3 is a lot better than Python2."

  print(s.rfind("Python"))
output: "29"
tag:
  - string/operation/rfind

---

code: |
  s = "Python3 is a lot better than Python2."

  print(s.rpartition("Python"))
output: "('Python3 is a lot better than ', 'Python', '2.')"
tag:
  - string/operation/rpartition

---

code: |
  s = "Python3 is a lot better than Python2."

  print(s.partition("Python"))
output: "('', 'Python', '3 is a lot better than Python2.')"
tag:
  - string/operation/partition

---

code: |
  a = "P".format("y")

  print(a)
output: "P"
tag:
  - string/operation/format

---

code: |
  b = "{2}{0}".format("p", "y", "p")

  print(b)
output: "pp"
tag:
  - string/operation/format

---

code: |
  st = 'hello'
  indx = st.index('l')
  st[indx] = 'p'

  print(st)
output: "TypeError: 'str' object does not support item assignment'"
tag:
  - string/immutable

---

code: |
  what = """i"""
  up = 'i'
  print(what is up)
output: "True"
tag:
  - string/operation/is

---

code: |
  lst = []
  lst = 'a'
  lst *= 2

  print(lst)
output: "aa"
tag:
  - string/operation/multiply

---

code: |
  values = '' or None

  print(values)
output: "None"
tag:
  - string/operation/empty_value

---

code: |
  a = '1'.encode()
  b = (1).encode()

  print(a == b)
output: "AttributeError: 'int' object has no attribute 'encode'"
tag:
  - string/operation/encode

---

code: |
  txt = "The best things in life are free!"

  print("free" in txt)
output: "True"
tag:
  - expression/operation/in
  - string/literal

---

code: |
  a = '1'.encode()
  b = (1).encode()

  print(a == b)
output: "AttributeError: 'int' object has no attribute 'encode'"
tag:
  - string/operation/encode

---

code: |
  txt = "hello, my name is Peter, I am 26 years old"
  x = txt.split(", ")

  print(x)
output: "['hello', 'my name is Peter', 'I am 26 years old']"
tag:
  - string/operation/split

---

code: |
  txt = "apple#banana#cherry#orange"
  x = txt.split("#", 1)

  print(x)
output: "['apple', 'banana#cherry#orange']"
tag:
  - string/operation/split

---

code: |
  txt = "Thank you for the music\nWelcome to the jungle\n"
  x = txt.splitlines()

  print(x)
output: "['Thank you for the music', 'Welcome to the jungle']"
tag:
  - string/operation/splitlines

---

code: |
  txt = "Thank you for the music\nWelcome to the jungle"
  x = txt.splitlines(True)

  print(x)
output: "['Thank you for the music\n', 'Welcome to the jungle']"
tag:
  - string/operation/splitlines

---

code: |
  mydict = {83:  80}
  txt = "Hello Sam!"

  print(txt.translate(mydict))
output: "Hello Pam!"
tag:
  - string/operation/translate

---

code: |
  txt = "Hi Sam!"
  x = "mSa"
  y = "eJo"
  mytable = txt.maketrans(x, y)

  print(txt.translate(mytable))
output: "Hi Joe!"
tag:
  - string/operation/maketrans
  - string/operation/translate

---

code: |
  txt = ",,,,,rrttgg.....banana....rrr"
  x = txt.strip(",.grt")
output: "banana"
tag:
  - string/operation/strip

---
code: |
  import threading

  def run(message):
    print(message)

  msg = "Hello, World"
  th = threading.Thread(target=run, args=(msg))

  th.start()
  th.join()
output: "TypeError: run() takes 1 positional argument but 12 were given"
tag:
  - thread/parameter/args

---

code: |
  import threading

  class A:
    def __init__(self, msg):
    self.msg = msg

    def say_hello(self):
    print(self.msg)

  a = A('Hello, World')

  th = threading.Thread(target=a.say_hello)

  th.start()
  th.join()
output: "Hello, World"
tag:
  - thread/parameter/target

---

code: |
  import multiprocessing

  def fact(value, answer):
    if value == 0:
    answer["value"] = 1
    answer["value"] = 1
    for i in range(1, value + 1):
    answer["value"] *= i

  answer = {
    "value": 0
  }

  th = multiprocessing.Process(target=fact, args=(5, answer))

  th.start()
  th.join()

  print(answer["value"])
output: "0"
tag:
  - thread/parameter

---

code: |
  import threading

  def fact(value, answer):
    if value == 0:
    answer["value"] = 1
    answer["value"] = 1
    for i in range(1, value + 1):
    answer["value"] *= i

  answer = {
    "value": 0
  }

  th = threading.Thread(target=fact, args=(5, answer))

  th.start()
  th.join()

  print(answer["value"])
output: "120"
tag:
  - process/parameter

---
code: |
  a = (el for el in range(5))
  b = (el for el in range(7, 13, 2))
  t = (a, b)
  print(t)
output: "(<generator object <genexpr> at 0x7f8f46f245f0>, <generator object <genexpr> at 0x7f8f46d255b0>)"
tag:
  - build-in/range
  - tuple
  - generator

---
code: |
  a = [6, 5, 8, 2, 1]
  t = tuple(el for el in a)
  print(t[1::-1])
output: "(5, 6)"
tag:
  - tuple/slice

---
code: |
  a = ()

  print(type(a))
output: "<class 'tuple'>"
tag:
  - tuple/literal

---
code: |
  tp = (0, 1)
  tp[0] = 1

  print(tp)
output: "TypeError: 'tuple' object does not support item assignment"
tag:
  - tuple/assignment

---
code: |
  t = ("Jake", "Mike", "O'Brien", "Tim", "George", "Heisenberg")
  t.sort(key=lambda x: len(x), reverse=True)
  
  print(t.index("Heisenberg"))
output: "AttributeError: 'tuple' object has no attribute 'sort'"
tag:
  - tuple

---
code: |
  t = ([17, 9, 59], 12, 9, "rt9y", 11, 3 * 3, 0., 9 / 3 * 3, "3" * 3)
  
  print(t.count(9))
output: "3"
tag:
  - tuple/operation/count

---
code: |
  tuple1 = (1, 2, 3)
  tuple2 = tuple(1, 2, 3)

  print(tuple1 == tuple2)
output: "TypeError: tuple expected at most 1 argument, got 3"
tag:
  - tuple/literal
  - build-in/tuple

---
code: |
  a = (1, 2, 3, 2, 1)
  b = range(1, 6)

  for x in b:
    if a.__contains__(x):
      a += (a.count(x),)

  print(a)
output: "(1, 2, 3, 2, 1, 2, 3, 2)"
tag:
  - tuple/operation/contains
  - tuple/operation/count
  - build-in/range

---

code: |
  def foo(value):
    t = value,
    return t

  print(foo(1))
output: "(1,)"
tag:
  - tuple/literal

---

code: |
  t1 = (11, 14, 54, 0, 58, 41)
  res = len(set(t1)) == len(t1)

  print(res)
output: "True"
tag:
  - tuple/literal
  - set/parameter

---

code: |
  value = (4, 5, 6)

  print(type(value) is tuple)
output: "True"
tag:
  - tuple/literal
  - type

---

code: |
  value = (1, 3, 7, 8, 7, 5, 4, 6, 8, 5)
  x = value.count(5)

  print(x)
output: "2"
tag:
  - tuple/operation/count

---

code: |
  value = (1, 3, 7, 8, 7, 5, 4, 6, 8, 5)
  x = value.index(8)

  print(x)
output: "3"
tag:
  - tuple/operation/index

---

code: |
  value = (1, 3, 7, 8, 7, 5, 4, 6, 8, 5)
  x = value.index(0)

  print(x)
output: "ValueError: tuple.index(x): x not in tuple"
tag:
  - tuple/operation/index

---
code: |
  from typing import Set

  a: Set[int] = {1, 4, 5}

  print(isinstance(a, Set[int]))
output: "TypeError: Subscripted generics cannot be used with class and instance checks"
tag:
  - type/annotation
  - built-in/isinstance

---

code: |
  a = (9)

  print(type(a))
output: "<class 'int'>"
tag:
  - int
  - type
  - build-in/type

---

code: |
  a = "Tree",

  print(type(a))
output: "<class 'tuple'>"
tag:
  - tuple
  - type
  - build-in/type

---

code: |
  a = "Hello"

  print(type(type(a)))
output: "<class 'type'>"
tag:
  - type
  - build-in/type

---

code: |
  a = (el for el in range(105))

  print(type(a))
output: "<class 'generator'>"
tag:
  - generator
  - type
  - build-in/type

---

code: |
  a = {}

  print(type(a))
output: "<class 'dict'>"
tag:
  - dict
  - type
  - build-in/type

---

code: |
  import math

  x = math.pow(2, 3)
  y = pow(2, 3)

  print(type(x) == type(y))
output: "False"
tag:
  - type/compare

---

code: |
  elements = {
    "key": "value",
    4: 20,
    "11": (1, 7, 2)
  }

  print(type(elements.keys()))
output: "<class 'dict_keys'>"
tag:
  - type
  - dict/operation/keys

---

code: |
  elements = {
    "key": "value",
    4: 20,
    "11": (1, 7, 2)
  }

  print(type(elements.values()))
output: "<class 'dict_values'>"
tag:
  - type
  - dict/operation/values

---
code: |
  a: float = 1
  b: float = 2

  print((a + b).bit_length())
output: "2"
tag:
  - type/annotation
  - int/operation/bit_length

---
code: |
  a: type = type(type)
  b = type(int)
  print(a is b)
output: "True"
tag:
  - type/annotation
  - build-in/type

---

code: |
  x = 3+5j

  print(type(x))
output: "<class 'complex'>"
tag:
  - complex
  - type
  - build-in/type

---

code: |
  text = b"Hello, World!!!"

  print(type(text))
output: "<class 'bytes'>"
tag:
  - bytes
  - type
  - build-in/type

---
